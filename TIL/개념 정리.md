# 개념 정리

## Virtual DOM

어플리케이션의 UI를 구성하는 HTML elements들을 메모리 내에서 구현한 것입니다. 컴포넌트가 다시 렌더링될 때 Virtual DOM은 업데이트할 요소의 목록을 만들기 위해 DOM 모델에서 변경되는 사항을 비교합니다.

덕분에 DOM 전체를 다시 렌더링하지 않고 최소한만 변경해 효율성이 높다는 장점이 있습니다.

## JSX

HTML처럼 보이는 코드를 작성할 수 있게 해주는 JS의 확장된 문법입니다. 컴파일시 JS 함수 호출 방식으로 바뀝니다.

```javascript
// 아래의 JSX는
<div className="sidebar" />;

// 이렇게 컴파일됩니다.
React.createElement("div", { className: "sidebar" });
```

## key

React에서 collection을 렌더링할 때 element와 data 사이의 관계를 추적하기 쉽도록 반복되는 각 element에 key를 부여해주어야 합니다. key는 고유한 ID(보통은 UUID 혹은 고유 문자열)를 사용해야 하나, key가 지정되지 않았을 경우 Array index를 자동으로 부여합니다.

key를 제대로 사용하지 않으면 collection에 item을 추가, 삭제할 때 예상치 못한 동작 결과가 발생할 수 있습니다.

## state, props

props는 부모 -> 자식 컴포넌트로 전달되는 데이터이며 수정될 수 없고 display 혹은 다른 값을 계산하는 데에만 사용됩니다. state는 컴포넌트의 lifecycle동안 수정될 수 있는 내부 데이터로, 다시 렌더링돼도 유지됩니다.

### setState

컴포넌트의 state를 직접 변경하려 해버리면 React는 컴포넌트를 다시 렌더링해야 하는지 알 수 있는 방법이 없습니다. 따라서 `setState()`를 통해서 state를 변경해야 합니다.

### prop으로 전달되는 값의 type을 강제 혹은 꼭 전달되게 강제

`prop-types` 패키지를 이용해 선언할 수 있습니다. 해당 패키지는 React 15.5까지는 React에 포함돼 있었다고 합니다.

## prop drilling

부모 -> 하위 컴포넌트들로 prop을 전달할 때 일어날 수 있는 상황으로, props를 전달하는 것 외에는 해당 props를 쓸 일이 없는 경우를 말합니다. 이 경우 그럴 필요가 없는데도 props가 바뀌었다는 이유만으로 불필요한 렌더링이 발생하게 됩니다.

컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트로 쪼개지 않고, state를 가장 가까운 부모 컴포넌트와만 공유해 이를 회피할 수 있습니다.

혹은, Redux, Context API 등과 같은 state 관리 라이브러리를 사용해 해결할 수도 있습니다.

### Context API

하나의 앱 안에서 복수의 컴포넌트들이 state를 공유할 때 발생할 수 있는 문제를 해결하기 위해 기본으로 제공되는 API입니다.

Flutter를 공부한 분이라면 `Provider`와 비슷한 역할을 한다고 생각하면 됩니다.

## Hooks

과거의 React.js는 함수형이 아닌 class를 이용해 컴포넌트들을 만들었다고 합니다. 이같은 업데이트는 Breaking Point는 아니었기 때문에 레거시 코드도 아직도 잘 돌아갑니다.

따라서, 실무에서 리액트를 다루면 class 형태의 컴포넌트들을 마주하게 될지도 모릅니다. 필요하다면 관련해 추가적인 학습이 필요합니다.

Hooks는 React 16.8 이후 도입된 시도로, 클래스 기반 컴포넌트의 장점을 함수형 컴포넌트로 가져온 것입니다.

이 덕분에 클래스 기반 컴포넌트, `this` 등이 필요가 없어졌습니다. 또한, 가독성이 좋아졌습니다.
